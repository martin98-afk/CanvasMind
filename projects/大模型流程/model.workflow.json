{
  "version": "1.0",
  "graph": {
    "nodes": {
      "0x1e1ec43dea0": {
        "name": "组件输入",
        "type_": "dynamic.StatusDynamicNode_数据集成_长文本输入",
        "pos": [
          -2183.692316696692,
          1716.551794001377
        ],
        "custom": {
          "FULL_PATH": "数据集成/长文本输入",
          "FILE_PATH": "",
          "params": {
            "input_text": "输入是两个csv，一个是feature，一个是target"
          },
          "input_values": {}
        }
      },
      "0x1e1ec48eb90": {
        "name": "组件输出",
        "type_": "dynamic.StatusDynamicNode_数据集成_长文本输入",
        "pos": [
          -2167.2633820555793,
          1882.1850401508473
        ],
        "custom": {
          "FULL_PATH": "数据集成/长文本输入",
          "FILE_PATH": "",
          "params": {
            "input_text": "输出是target预测结果和模型"
          },
          "input_values": {}
        }
      },
      "0x1e1e90c6b00": {
        "name": "组件意图",
        "type_": "dynamic.StatusDynamicNode_数据集成_长文本输入",
        "pos": [
          -2134.57027533123,
          1539.8844005964938
        ],
        "custom": {
          "FULL_PATH": "数据集成/长文本输入",
          "FILE_PATH": "",
          "params": {
            "input_text": "我的需求是开发一个逻辑回归组件"
          },
          "input_values": {}
        }
      },
      "0x1e1ec44d780": {
        "name": "JSON文本包装 1",
        "type_": "dynamic.StatusDynamicNode_大模型组件_JSON文本包装",
        "pos": [
          -1685.5683197675417,
          1723.8047438774283
        ],
        "custom": {
          "FULL_PATH": "大模型组件/JSON文本包装",
          "FILE_PATH": "",
          "params": {
            "prop_0": "input"
          },
          "input_values": {
            "input1": "输入是两个csv，一个是feature，一个是target"
          }
        }
      },
      "0x1e1ec46ce20": {
        "name": "JSON文本包装 3",
        "type_": "dynamic.StatusDynamicNode_大模型组件_JSON文本包装",
        "pos": [
          -1650.0577512331129,
          1884.7859879001708
        ],
        "custom": {
          "FULL_PATH": "大模型组件/JSON文本包装",
          "FILE_PATH": "",
          "params": {
            "prop_0": "output"
          },
          "input_values": {
            "input1": "输出是target预测结果和模型"
          }
        }
      },
      "0x1e1ebee9630": {
        "name": "JSON文本包装",
        "type_": "dynamic.StatusDynamicNode_大模型组件_JSON文本包装",
        "pos": [
          -1579.4598118143058,
          1540.4696945483502
        ],
        "custom": {
          "FULL_PATH": "大模型组件/JSON文本包装",
          "FILE_PATH": "",
          "params": {
            "prop_0": "intention"
          },
          "input_values": {
            "input1": "我的需求是开发一个逻辑回归组件"
          }
        }
      },
      "0x1e1ec299ea0": {
        "name": "提示词模板 3",
        "type_": "dynamic.StatusDynamicNode_大模型组件_提示词模板",
        "pos": [
          -1161.7453401291973,
          1701.043348786944
        ],
        "custom": {
          "FULL_PATH": "大模型组件/提示词模板",
          "FILE_PATH": "",
          "params": {
            "template": "##  任务\n根据我的组件输入、输出、节点参数定义以及我的样例代码、需求等信息自动生成完整的python组件代码\n\n## 组件输入输出参数定义代码\nclass ArgumentType(str, Enum):\n    \"\"\"参数类型\"\"\"\n    TEXT = \"文本\"\n    INT = \"整数\"\n    FLOAT = \"浮点数\"\n    BOOL = \"布尔值\"\n    ARRAY = \"列表\"\n    CSV = \"csv\"\n    JSON = \"json\"\n    EXCEL = \"excel\"\n    FILE = \"文件\"\n    UPLOAD = \"上传\"\n    SKLEARNMODEL = \"sklearn模型\"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    TORCHMODEL = \"torch模型\"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    IMAGE = \"图片\"\n\nclass PortDefinition(BaseModel):\n    \"\"\"端口定义\"\"\"\n    name: str\n    label: str\n    type: ArgumentType = ArgumentType.TEXT\n\n## 组件属性参数定义代码\nclass PropertyType(str, Enum):\n    \"\"\"属性类型\"\"\"\n    TEXT = \"文本\"\n    LONGTEXT = \"长文本\"\n    INT = \"整数\"\n    FLOAT = \"浮点数\"\n    RANGE = \"范围\"\n    BOOL = \"复选框\"\n    CHOICE = \"下拉框\"\n    DYNAMICFORM = \"动态表单\"\n\n\nclass PropertyDefinition(BaseModel):\n    \"\"\"属性定义\"\"\"\n    type: PropertyType = PropertyType.TEXT\n    default: Any = \"\"\n    label: str = \"\"\n    choices: List[str] = Field(default_factory=list)\n    filter: str = \"All Files (*)\"  # 用于文件类型过滤\n    schema: Optional[Dict[str, 'PropertyDefinition']] = Field(default=None)  # 表单内每个字段的定义\n    min: float = Field(default=0.0, description=\"最小值\")\n    max: float = Field(default=100.0, description=\"最大值\")\n    step: float = Field(default=1.0, description=\"步长\")\n\n    class Config:\n        # 允许递归引用\n        arbitrary_types_allowed = True\n\n## 我的组件样例代码\nclass Component(BaseComponent):\n    name = \"提示词模板\"\n    category = \"大模型组件\"\n    description = \"\"\n    requirements = \"\"\n\n    inputs = [\n        PortDefinition(name=\"variables\", label=\"变量字典\", type=ArgumentType.JSON),\n    ]\n    outputs = [\n        PortDefinition(name=\"prompt\", label=\"生成的提示词\", type=ArgumentType.TEXT),\n    ]\n\n    properties = {\n        \"template\": PropertyDefinition(\n            type=PropertyType.LONGTEXT,\n            default=\"\"\"你好，{{name}}！今天是{{day}}。\"\"\",\n            label=\"提示词模板\",\n        ),\n    }\n\n    def run(self, params, inputs = None):\n        import re\n        self.logger.info(inputs)\n        template = params.get(\"template\", \"\")\n        variables = inputs.get(\"variables\", {}) if inputs else {}\n\n        if isinstance(variables, str):\n            import json\n            try:\n                variables = json.loads(variables)\n            except:\n                variables = {}\n\n        # 替换 {{key}} 为变量值\n        def replace_match(match):\n            key = match.group(1)\n            return str(variables.get(key, match.group(0)))\n\n        prompt = re.sub(r\"\\{\\{(\\w+)\\}\\}\", replace_match, template)\n        self.logger.info(prompt)\n        \n        return {\"prompt\": prompt}\n\n## 组件开发需求\n{{intention}}\n\n## 组件输入参数\n{{input}}\n\n## 组件输出参数\n{{output}}\n\n## 代码输出要求\n输出代码不需要包含输入、输出以及属性参数定义代码，这部分已经写好了，同时第三方工具包导入时只能在函数内导入，不能在文件开头导入，不要引入Dict，List这些参数格式定义。\n\n## 生成的组件代码\n"
          },
          "input_values": {
            "variables": [
              {
                "intention": "我的需求是开发一个逻辑回归组件"
              },
              {
                "input": "输入是两个csv，一个是feature，一个是target"
              },
              {
                "output": "输出是target预测结果和模型"
              }
            ]
          }
        }
      }
    },
    "connections": [
      {
        "out": [
          "0x1e1e90c6b00",
          "output"
        ],
        "in": [
          "0x1e1ebee9630",
          "input1"
        ]
      },
      {
        "out": [
          "0x1e1ebee9630",
          "output1"
        ],
        "in": [
          "0x1e1ec299ea0",
          "variables"
        ]
      },
      {
        "out": [
          "0x1e1ec44d780",
          "output1"
        ],
        "in": [
          "0x1e1ec299ea0",
          "variables"
        ]
      },
      {
        "out": [
          "0x1e1ec46ce20",
          "output1"
        ],
        "in": [
          "0x1e1ec299ea0",
          "variables"
        ]
      },
      {
        "out": [
          "0x1e1ec43dea0",
          "output"
        ],
        "in": [
          "0x1e1ec44d780",
          "input1"
        ]
      },
      {
        "out": [
          "0x1e1ec48eb90",
          "output"
        ],
        "in": [
          "0x1e1ec46ce20",
          "input1"
        ]
      }
    ],
    "grid": null
  },
  "runtime": {
    "environment": "3.11",
    "environment_exe": "D:\\work\\WorkFlowGUI\\envs\\miniconda\\envs\\3.11\\python.exe",
    "node_id2stable_key": {
      "0x1e1ec43dea0": "数据集成/长文本输入||组件输入",
      "0x1e1ec48eb90": "数据集成/长文本输入||组件输出",
      "0x1e1e90c6b00": "数据集成/长文本输入||组件意图",
      "0x1e1ec44d780": "大模型组件/JSON文本包装||JSON文本包装 1",
      "0x1e1ec46ce20": "大模型组件/JSON文本包装||JSON文本包装 3",
      "0x1e1ebee9630": "大模型组件/JSON文本包装||JSON文本包装",
      "0x1e1ec299ea0": "大模型组件/提示词模板||提示词模板 3"
    },
    "node_states": {
      "数据集成/长文本输入||组件输入": "success",
      "数据集成/长文本输入||组件输出": "success",
      "数据集成/长文本输入||组件意图": "success",
      "大模型组件/JSON文本包装||JSON文本包装 1": "success",
      "大模型组件/JSON文本包装||JSON文本包装 3": "success",
      "大模型组件/JSON文本包装||JSON文本包装": "success",
      "大模型组件/提示词模板||提示词模板 3": "success"
    },
    "node_outputs": {
      "数据集成/长文本输入||组件输入": {
        "output": "输入是两个csv，一个是feature，一个是target"
      },
      "数据集成/长文本输入||组件输出": {
        "output": "输出是target预测结果和模型"
      },
      "数据集成/长文本输入||组件意图": {
        "output": "我的需求是开发一个逻辑回归组件"
      },
      "大模型组件/JSON文本包装||JSON文本包装 1": {
        "output1": {
          "input": "输入是两个csv，一个是feature，一个是target"
        }
      },
      "大模型组件/JSON文本包装||JSON文本包装 3": {
        "output1": {
          "output": "输出是target预测结果和模型"
        }
      },
      "大模型组件/JSON文本包装||JSON文本包装": {
        "output1": {
          "intention": "我的需求是开发一个逻辑回归组件"
        }
      },
      "大模型组件/提示词模板||提示词模板 3": {
        "prompt": "##  任务\n根据我的组件输入、输出、节点参数定义以及我的样例代码、需求等信息自动生成完整的python组件代码\n\n## 组件输入输出参数定义代码\nclass ArgumentType(str, Enum):\n    \"\"\"参数类型\"\"\"\n    TEXT = \"文本\"\n    INT = \"整数\"\n    FLOAT = \"浮点数\"\n    BOOL = \"布尔值\"\n    ARRAY = \"列表\"\n    CSV = \"csv\"\n    JSON = \"json\"\n    EXCEL = \"excel\"\n    FILE = \"文件\"\n    UPLOAD = \"上传\"\n    SKLEARNMODEL = \"sklearn模型\"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    TORCHMODEL = \"torch模型\"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    IMAGE = \"图片\"\n\nclass PortDefinition(BaseModel):\n    \"\"\"端口定义\"\"\"\n    name: str\n    label: str\n    type: ArgumentType = ArgumentType.TEXT\n\n## 组件属性参数定义代码\nclass PropertyType(str, Enum):\n    \"\"\"属性类型\"\"\"\n    TEXT = \"文本\"\n    LONGTEXT = \"长文本\"\n    INT = \"整数\"\n    FLOAT = \"浮点数\"\n    RANGE = \"范围\"\n    BOOL = \"复选框\"\n    CHOICE = \"下拉框\"\n    DYNAMICFORM = \"动态表单\"\n\n\nclass PropertyDefinition(BaseModel):\n    \"\"\"属性定义\"\"\"\n    type: PropertyType = PropertyType.TEXT\n    default: Any = \"\"\n    label: str = \"\"\n    choices: List[str] = Field(default_factory=list)\n    filter: str = \"All Files (*)\"  # 用于文件类型过滤\n    schema: Optional[Dict[str, 'PropertyDefinition']] = Field(default=None)  # 表单内每个字段的定义\n    min: float = Field(default=0.0, description=\"最小值\")\n    max: float = Field(default=100.0, description=\"最大值\")\n    step: float = Field(default=1.0, description=\"步长\")\n\n    class Config:\n        # 允许递归引用\n        arbitrary_types_allowed = True\n\n## 我的组件样例代码\nclass Component(BaseComponent):\n    name = \"提示词模板\"\n    category = \"大模型组件\"\n    description = \"\"\n    requirements = \"\"\n\n    inputs = [\n        PortDefinition(name=\"variables\", label=\"变量字典\", type=ArgumentType.JSON),\n    ]\n    outputs = [\n        PortDefinition(name=\"prompt\", label=\"生成的提示词\", type=ArgumentType.TEXT),\n    ]\n\n    properties = {\n        \"template\": PropertyDefinition(\n            type=PropertyType.LONGTEXT,\n            default=\"\"\"你好，{{name}}！今天是{{day}}。\"\"\",\n            label=\"提示词模板\",\n        ),\n    }\n\n    def run(self, params, inputs = None):\n        import re\n        self.logger.info(inputs)\n        template = params.get(\"template\", \"\")\n        variables = inputs.get(\"variables\", {}) if inputs else {}\n\n        if isinstance(variables, str):\n            import json\n            try:\n                variables = json.loads(variables)\n            except:\n                variables = {}\n\n        # 替换 {{key}} 为变量值\n        def replace_match(match):\n            key = match.group(1)\n            return str(variables.get(key, match.group(0)))\n\n        prompt = re.sub(r\"\\{\\{(\\w+)\\}\\}\", replace_match, template)\n        self.logger.info(prompt)\n        \n        return {\"prompt\": prompt}\n\n## 组件开发需求\n我的需求是开发一个逻辑回归组件\n\n## 组件输入参数\n输入是两个csv，一个是feature，一个是target\n\n## 组件输出参数\n输出是target预测结果和模型\n\n## 代码输出要求\n输出代码不需要包含输入、输出以及属性参数定义代码，这部分已经写好了，同时第三方工具包导入时只能在函数内导入，不能在文件开头导入，不要引入Dict，List这些参数格式定义。\n\n## 生成的组件代码\n"
      }
    },
    "column_select": {
      "数据集成/长文本输入||组件输入": {},
      "数据集成/长文本输入||组件输出": {},
      "数据集成/长文本输入||组件意图": {},
      "大模型组件/JSON文本包装||JSON文本包装 1": {},
      "大模型组件/JSON文本包装||JSON文本包装 3": {},
      "大模型组件/JSON文本包装||JSON文本包装": {},
      "大模型组件/提示词模板||提示词模板 3": {}
    }
  }
}