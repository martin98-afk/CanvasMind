INFO:     Started server process [33264]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
[32m2025-10-11 20:17:36.199[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: 组件输入[0m
[32m2025-10-11 20:17:36.857[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:36.806[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:36.859[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: 组件输出[0m
[32m2025-10-11 20:17:37.522[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:37.477[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:37.523[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: 组件意图[0m
[32m2025-10-11 20:17:38.170[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:38.121[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:38.171[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: JSON文本包装 1[0m
[32m2025-10-11 20:17:38.770[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:38.724[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:38.773[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: JSON文本包装 3[0m
[32m2025-10-11 20:17:39.380[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:39.333[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:39.382[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: JSON文本包装[0m
[32m2025-10-11 20:17:40.025[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:39.972[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:40.026[0m | [1mINFO    [0m | [36mrunner.workflow_runner[0m:[36mexecute_workflow[0m:[36m156[0m - [1m执行节点: 提示词模板 3[0m
[32m2025-10-11 20:17:40.698[0m | [33m[1mWARNING [0m | [36mrunner.component_executor[0m:[36m_run_subprocess[0m:[36m173[0m - [33m[1m子进程 stderr:
[32m2025-10-11 20:17:40.651[0m | [1mINFO    [0m | [36m__main__[0m:[36minfo[0m:[36m26[0m - [1m{'variables': [{'intention': '我的需求是开发一个逻辑回归组件'}, {'input': '输入是两个csv，一个是feature，一个是target'}, {'output': '输出是target预测结果和模型'}]}[0m
[32m2025-10-11 20:17:40.651[0m | [1mINFO    [0m | [36m__main__[0m:[36minfo[0m:[36m26[0m - [1m##  任务
根据我的组件输入、输出、节点参数定义以及我的样例代码、需求等信息自动生成完整的python组件代码

## 组件输入输出参数定义代码
class ArgumentType(str, Enum):
    """参数类型"""
    TEXT = "文本"
    INT = "整数"
    FLOAT = "浮点数"
    BOOL = "布尔值"
    ARRAY = "列表"
    CSV = "csv"
    JSON = "json"
    EXCEL = "excel"
    FILE = "文件"
    UPLOAD = "上传"
    SKLEARNMODEL = "sklearn模型"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储
    TORCHMODEL = "torch模型"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储
    IMAGE = "图片"

class PortDefinition(BaseModel):
    """端口定义"""
    name: str
    label: str
    type: ArgumentType = ArgumentType.TEXT

## 组件属性参数定义代码
class PropertyType(str, Enum):
    """属性类型"""
    TEXT = "文本"
    LONGTEXT = "长文本"
    INT = "整数"
    FLOAT = "浮点数"
    RANGE = "范围"
    BOOL = "复选框"
    CHOICE = "下拉框"
    DYNAMICFORM = "动态表单"


class PropertyDefinition(BaseModel):
    """属性定义"""
    type: PropertyType = PropertyType.TEXT
    default: Any = ""
    label: str = ""
    choices: List[str] = Field(default_factory=list)
    filter: str = "All Files (*)"  # 用于文件类型过滤
    schema: Optional[Dict[str, 'PropertyDefinition']] = Field(default=None)  # 表单内每个字段的定义
    min: float = Field(default=0.0, description="最小值")
    max: float = Field(default=100.0, description="最大值")
    step: float = Field(default=1.0, description="步长")

    class Config:
        # 允许递归引用
        arbitrary_types_allowed = True

## 我的组件样例代码
class Component(BaseComponent):
    name = "提示词模板"
    category = "大模型组件"
    description = ""
    requirements = ""

    inputs = [
        PortDefinition(name="variables", label="变量字典", type=ArgumentType.JSON),
    ]
    outputs = [
        PortDefinition(name="prompt", label="生成的提示词", type=ArgumentType.TEXT),
    ]

    properties = {
        "template": PropertyDefinition(
            type=PropertyType.LONGTEXT,
            default="""你好，{{name}}！今天是{{day}}。""",
            label="提示词模板",
        ),
    }

    def run(self, params, inputs = None):
        import re
        self.logger.info(inputs)
        template = params.get("template", "")
        variables = inputs.get("variables", {}) if inputs else {}

        if isinstance(variables, str):
            import json
            try:
                variables = json.loads(variables)
            except:
                variables = {}

        # 替换 {{key}} 为变量值
        def replace_match(match):
            key = match.group(1)
            return str(variables.get(key, match.group(0)))

        prompt = re.sub(r"\{\{(\w+)\}\}", replace_match, template)
        self.logger.info(prompt)
        
        return {"prompt": prompt}

## 组件开发需求
我的需求是开发一个逻辑回归组件

## 组件输入参数
输入是两个csv，一个是feature，一个是target

## 组件输出参数
输出是target预测结果和模型

## 代码输出要求
输出代码不需要包含输入、输出以及属性参数定义代码，这部分已经写好了，同时第三方工具包导入时只能在函数内导入，不能在文件开头导入，不要引入Dict，List这些参数格式定义。

## 生成的组件代码
[0m
[32m2025-10-11 20:17:40.652[0m | [32m[1mSUCCESS [0m | [36m__main__[0m:[36msuccess[0m:[36m27[0m - [32m[1m执行完成[0m
[0m
[32m2025-10-11 20:17:40.700[0m | [1mINFO    [0m | [36m__main__[0m:[36mrun_workflow[0m:[36m117[0m - [1m工作流执行成功，结果：{'prompt': '##  任务\n根据我的组件输入、输出、节点参数定义以及我的样例代码、需求等信息自动生成完整的python组件代码\n\n## 组件输入输出参数定义代码\nclass ArgumentType(str, Enum):\n    """参数类型"""\n    TEXT = "文本"\n    INT = "整数"\n    FLOAT = "浮点数"\n    BOOL = "布尔值"\n    ARRAY = "列表"\n    CSV = "csv"\n    JSON = "json"\n    EXCEL = "excel"\n    FILE = "文件"\n    UPLOAD = "上传"\n    SKLEARNMODEL = "sklearn模型"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    TORCHMODEL = "torch模型"    # 模型类型不需要保存到本地，直接返回后后端代码会自动进行存储\n    IMAGE = "图片"\n\nclass PortDefinition(BaseModel):\n    """端口定义"""\n    name: str\n    label: str\n    type: ArgumentType = ArgumentType.TEXT\n\n## 组件属性参数定义代码\nclass PropertyType(str, Enum):\n    """属性类型"""\n    TEXT = "文本"\n    LONGTEXT = "长文本"\n    INT = "整数"\n    FLOAT = "浮点数"\n    RANGE = "范围"\n    BOOL = "复选框"\n    CHOICE = "下拉框"\n    DYNAMICFORM = "动态表单"\n\n\nclass PropertyDefinition(BaseModel):\n    """属性定义"""\n    type: PropertyType = PropertyType.TEXT\n    default: Any = ""\n    label: str = ""\n    choices: List[str] = Field(default_factory=list)\n    filter: str = "All Files (*)"  # 用于文件类型过滤\n    schema: Optional[Dict[str, \'PropertyDefinition\']] = Field(default=None)  # 表单内每个字段的定义\n    min: float = Field(default=0.0, description="最小值")\n    max: float = Field(default=100.0, description="最大值")\n    step: float = Field(default=1.0, description="步长")\n\n    class Config:\n        # 允许递归引用\n        arbitrary_types_allowed = True\n\n## 我的组件样例代码\nclass Component(BaseComponent):\n    name = "提示词模板"\n    category = "大模型组件"\n    description = ""\n    requirements = ""\n\n    inputs = [\n        PortDefinition(name="variables", label="变量字典", type=ArgumentType.JSON),\n    ]\n    outputs = [\n        PortDefinition(name="prompt", label="生成的提示词", type=ArgumentType.TEXT),\n    ]\n\n    properties = {\n        "template": PropertyDefinition(\n            type=PropertyType.LONGTEXT,\n            default="""你好，{{name}}！今天是{{day}}。""",\n            label="提示词模板",\n        ),\n    }\n\n    def run(self, params, inputs = None):\n        import re\n        self.logger.info(inputs)\n        template = params.get("template", "")\n        variables = inputs.get("variables", {}) if inputs else {}\n\n        if isinstance(variables, str):\n            import json\n            try:\n                variables = json.loads(variables)\n            except:\n                variables = {}\n\n        # 替换 {{key}} 为变量值\n        def replace_match(match):\n            key = match.group(1)\n            return str(variables.get(key, match.group(0)))\n\n        prompt = re.sub(r"\\{\\{(\\w+)\\}\\}", replace_match, template)\n        self.logger.info(prompt)\n        \n        return {"prompt": prompt}\n\n## 组件开发需求\n我的需求是开发一个逻辑回归组件\n\n## 组件输入参数\n输入是两个csv，一个是feature，一个是target\n\n## 组件输出参数\n输出是target预测结果和模型\n\n## 代码输出要求\n输出代码不需要包含输入、输出以及属性参数定义代码，这部分已经写好了，同时第三方工具包导入时只能在函数内导入，不能在文件开头导入，不要引入Dict，List这些参数格式定义。\n\n## 生成的组件代码\n'}[0m
INFO:     127.0.0.1:54626 - "POST /run HTTP/1.1" 200 OK
