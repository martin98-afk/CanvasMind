# -*- coding: utf-8 -*-
import ast

import os
import shutil
import subprocess
from pathlib import Path


def clean_build_dirs():
    for dir_name in ["dist", "build"]:
        if os.path.exists(dir_name):
            print(f"🧹 清理目录: {dir_name}")
            shutil.rmtree(dir_name)


def generate_hidden_imports():
    """生成组件的隐藏导入"""
    app_dir = Path("app") / "components"
    if not app_dir.exists():
        raise FileNotFoundError("app/components 目录不存在")

    imports = []
    for py_file in app_dir.rglob("*.py"):
        if py_file.name in ("__init__.py", "base.py"):
            continue
        rel = py_file.relative_to(Path("."))
        mod = str(rel).replace(os.sep, '.')[:-3]
        imports.append(f"--hidden-import={mod}")
    return imports


def build():
    # 👇 先生成预导入脚本
    cmd = [
        "pyinstaller",
        "--onedir",
        "--windowed",
        "-y",
        "--add-data", "app;app",
        "--add-data", "icons;icons",
    ]

    cmd.append("main.py")

    print("📦 执行打包命令：")
    print(" ".join(cmd))

    result = subprocess.run(cmd)
    if result.returncode == 0:
        print("✅ 打包完成！")
    else:
        print("❌ 打包失败，请检查错误信息")


def extract_imports_from_file(file_path):
    """从 Python 文件中提取所有顶层 import 语句"""
    imports = set()
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            tree = ast.parse(f.read())

        for node in ast.walk(tree):
            # 处理 import xxx
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split('.')[0])
            # 处理 from xxx import yyy
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split('.')[0])
    except Exception as e:
        print(f"⚠️ 无法解析 {file_path}: {e}")

    return imports


def generate_preimport_script():
    """扫描所有组件文件，生成预导入脚本"""
    components_dir = Path("app") / "components"
    if not components_dir.exists():
        print("❌ app/components 目录不存在")
        return None

    all_imports = set()

    # 扫描所有 .py 文件
    for py_file in components_dir.rglob("*.py"):
        if py_file.name in ("__init__.py", "base.py"):
            continue
        imports = extract_imports_from_file(py_file)
        all_imports.update(imports)

    # 过滤掉标准库和本地模块
    # 保留可能需要 PyInstaller 特殊处理的第三方库
    third_party_libs = {
        'pandas', 'numpy', 'scipy', 'matplotlib', 'seaborn', 'sklearn',
        'torch', 'tensorflow', 'cv2', 'PIL', 'requests', 'yaml', 'json',
        'openpyxl', 'xlrd', 'xlwt', 'sqlalchemy', 'psycopg2', 'mysql',
        'pyodbc', 'pymongo', 'redis', 'kafka', 'boto3', 'azure', 'google',
        'plotly', 'bokeh', 'dash', 'streamlit', 'fastapi', 'flask',
        'django', 'celery', 'apscheduler', 'schedule', 'loguru'
    }

    # 只保留第三方库（可以根据你的项目调整这个列表）
    pre_imports = all_imports & third_party_libs

    # 也可以选择不过滤，直接导入所有（但可能包含无效模块）
    # pre_imports = all_imports

    if not pre_imports:
        print("⚠️ 没有发现需要预导入的第三方库")
        return None

    # 生成预导入代码
    preimport_code = "# Auto-generated pre-imports for PyInstaller compatibility\n"
    preimport_code += "# DO NOT EDIT - generated by gen_preimports.py\n\n"

    for lib in sorted(pre_imports):
        preimport_code += f"try:\n    import {lib}\nexcept ImportError:\n    pass  # Optional dependency\n"

    return preimport_code


def save_preimport_script():
    """保存预导入脚本到 pre_imports.py"""
    code = generate_preimport_script()
    if code:
        with open("pre_imports.py", "w", encoding="utf-8") as f:
            f.write(code)
        print("✅ 生成 pre_imports.py 成功")
        print("生成的导入模块:", sorted(
            [line.split()[-1] for line in code.split('\n') if 'import' in line and not line.strip().startswith('#')]))
    else:
        # 创建空文件避免导入错误
        with open("pre_imports.py", "w", encoding="utf-8") as f:
            f.write("# No pre-imports needed\n")
        print("✅ 创建空的 pre_imports.py")


if __name__ == "__main__":
    save_preimport_script()
    build()